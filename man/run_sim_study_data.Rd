% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/run_sim_study_data.R
\name{run_sim_study_data}
\alias{run_sim_study_data}
\title{Reproducible Simulation Study (Real Data)}
\usage{
run_sim_study_data(
  fit_func,
  pred_func = NULL,
  dnames = get_sim_data_tiny(),
  dsets = NULL,
  folds = 20,
  seed = 42,
  conf_level = c(0.8, 0.9, 0.95, 0.99),
  score = TRUE,
  x_scale01 = TRUE,
  method_names = NULL,
  custom_data_names = NULL,
  mc_cores = 1,
  fallback_on_error = TRUE,
  print_error = FALSE,
  verbose = TRUE
)
}
\arguments{
\item{fit_func}{If \code{pred_func} is specified, the \code{fit_func} should take two arguments called \code{X_train} and \code{y_train}, and should return an object which will be passed to \code{pred_func}. If \code{pred_func} is NOT specified, then \code{fit_func} should take a third argument called \code{X_test}, and should return predictive samples (see pred_func documentation).}

\item{pred_func}{A function taking two arguments: (i) the object returned by \code{fit_func} and a matrix \code{X_test}. The function should return an matrix of samples from the predictive distribution, with one column per test point. For additional flexibility, see the details below.}

\item{dnames}{A vector of dataset names from the \code{duqling} package. See \code{data_quack()} for details.}

\item{dsets}{A list of datasets. Each list component is a list with elements \code{X} (a matrix) and \code{y} (a vector).}

\item{folds}{Number of folds in cross validation. Can be a scalar or a vector (with \code{length(folds) == length(dnames)}). If \code{folds} is negative, then a Bootstrap Cross-Validation procedure is run \code{-folds} times.}

\item{seed}{Seed for random number generators. For reproducibility, we discourage the use of this argument.}

\item{conf_level}{Confidence level for interval estimates. If \code{length(conf_level) > 1}, then \code{pred_func} should return a matrix with \code{1 + 2*length(conf_level)} columns, with 2 columns of lower and upper bounds for each value in \code{conf_}}

\item{score}{Logical. Should CRPS be computed?}

\item{x_scale01}{Logical. Should the inputs be internally scaled to be between 0 and 1? (Default TRUE).}

\item{method_names}{A vector of method names, length equal to \code{length(fit_func)}. If NULL, the indexed names \code{my_method<i>} will be used.}

\item{custom_data_names}{An optional vector of dataset names corresponding to the argument \code{dsets}.}

\item{mc_cores}{How many cores to use for parallelization over replications.}

\item{fallback_on_error}{When \code{TRUE} (default), we use a null model (\code{N(mean(y_train), sd(y_train))}) for robustness if a failure is detected in either \code{fit_func} or \code{pred_func}.}

\item{print_error}{Logical (default FALSE). Should error messages (from \code{fit_func} or \code{pred_func})be printed?}

\item{verbose}{should progress be reported?}
}
\value{
A data frame with one row per dataset × fold × method combination. Columns include:
  \itemize{
    \item \code{dname}: Dataset name.
    \item \code{method}: Method name.
    \item \code{n}: Number of test points in the fold.
    \item \code{input_dim}: Input dimension.
    \item \code{fold}: Fold index.
    \item \code{fold_size}: Number of points in the fold.
    \item \code{t_fit}: Elapsed time (seconds) for model fitting (if applicable).
    \item \code{t_pred}: Elapsed time (seconds) for model prediction (if applicable).
    \item \code{t_tot}: Total elapsed time for fitting and prediction.
    \item \code{failure_type}: Indicates if the method failed at "fit", "pred", or "none" (if no failure).
    \item \code{RMSE}: Root mean squared error on the test set.
    \item \code{FVU}: Fraction of variance unexplained (RMSE^2 divided by total variance).
    \item \code{COVER<level>}: Coverage rates for each specified confidence level (e.g., \code{COVER0.8}, \code{COVER0.9}, etc.).
    \item \code{MIS<level>}: Mean interval scores for each specified confidence level.
    \item \code{CRPS}: Mean continuous ranked probability score (CRPS) on the test set.
    \item \code{CRPS_min}, \code{CRPS_Q1}, \code{CRPS_med}, \code{CRPS_Q3}, \code{CRPS_max}: Summary statistics (minimum, first quartile, median, third quartile, maximum) for the CRPS distribution over the test set.
  }
}
\description{
Reproducible code for simulation studies with real data sets.
}
\details{
Code to conduct a reproducible simulation study to compare emulators. By reporting the parameters to the study, other authors can compare their results directly.
Only \code{fit_func} needs to be specified, but only the total time will be reported. The simplest (and recommended) approach is that the \code{fit_func} (or \code{pred_func}) should return a matrix of posterior samples, with one column per test point (e.g., per row in \code{X_test}). Any number of rows (predictive samples) is allowed. In this case, the mean of the samples is used as a prediction and the R \code{stats::quantile} function is used to construct confidence intervals. This default behavior can be changed by instead allowing \code{fit_func} (or \code{pred_func}) to return a named list with fields i) \code{samples} (required), ii) \code{preds} (optional; a vector of predictions), and iii) intervals (optional; a 2 by n by k array of interval bounds where n is the number of test points and k is \code{length(conf_level)}).
}
\examples{
\dontrun{
my_fit <- function(X, y) lm(y ~ ., data = as.data.frame(X))
my_pred <- function(mod, Xt) {
  mu <- predict(mod, as.data.frame(Xt))
  s  <- sd(residuals(mod))
  replicate(1000, mu + rnorm(length(mu), 0, s))
}

run_sim_study_data(fit_func = my_fit,
                   pred_func = my_pred,
                   dnames = c("pbx9501_gold"),
                   folds = 5)
}
}
\references{
Surjanovic, Sonja, and Derek Bingham. "Virtual library of simulation experiments: test functions and datasets." Simon Fraser University, Burnaby, BC, Canada, accessed May 13 (2013): 2015.
}
